# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.11
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import *
from PyQt5.QtCore import QThread, pyqtSignal,QObject
from PyQt5.QtGui import QTextCursor, QPalette, QColor, QFont, QIcon, QPixmap
import sys  # 导入sys模块
import logging
import os
import glob
from pathlib import Path
from typing import List
import subprocess
import base64
import shutil
from cryptography import x509
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend

def split_file(input_path: str, chunk_size: int = 200, log_callback=None) -> List[str]:
    log_func = lambda msg: log_callback(msg) if log_callback else None
    log_func(f"开始拆分文件：{input_path}")
    if not os.path.exists(input_path):
        error_msg = f"文件不存在：{input_path}"
        log_func(f"ERROR - {error_msg}")
        raise FileNotFoundError(error_msg)

    chunk_prefix = os.path.join(os.path.dirname(input_path), "private_part_")
    chunk_files = []
    chunk_index = 0

    with open(input_path, "rb") as f:
        while True:
            chunk_data = f.read(chunk_size)
            if not chunk_data:
                break
            suffix = chr(97 + (chunk_index // 26)) + chr(97 + (chunk_index % 26))
            chunk_file = f"{chunk_prefix}{suffix}"
            chunk_files.append(chunk_file)
            with open(chunk_file, "wb") as cf:
                cf.write(chunk_data)
            chunk_index += 1
    log_func(f"文件拆分完成，生成 {len(chunk_files)} 个分片")
    return chunk_files


def encrypt_chunk(chunk_path: str, pubkey_path: str, log_callback=None) -> str:
    log_func = lambda msg: log_callback(msg) if log_callback else None
    log_func(f"开始加密分片：{os.path.basename(chunk_path)}")
    with open(pubkey_path, "rb") as f:
        try:
            pubkey = serialization.load_pem_public_key(f.read(), backend=default_backend())
        except Exception as e:
            error_msg = f"公钥文件解析失败：{str(e)}"
            log_func(f"ERROR - {error_msg}")
            raise

    with open(chunk_path, "rb") as f:
        chunk_data = f.read()

    encrypted_data = pubkey.encrypt(chunk_data, padding.PKCS1v15())
    enc_file = f"{chunk_path}.enc"
    with open(enc_file, "wb") as f:
        f.write(encrypted_data)
    log_func(f"分片加密完成：{os.path.basename(enc_file)}")
    return enc_file


def merge_enc_files(enc_files: List[str], output_path: str, log_callback=None) -> None:
    log_func = lambda msg: log_callback(msg) if log_callback else None
    log_func(f"开始合并加密文件，共 {len(enc_files)} 个分片")
    with open(output_path, "wb") as out_f:
        for ef in enc_files:
            with open(ef, "rb") as in_f:
                out_f.write(in_f.read())
    log_func(f"合并完成：{os.path.basename(output_path)}")


def base64_encode_file(input_path: str, output_path: str, line_length: int = 64, log_callback=None) -> None:
    log_func = lambda msg: log_callback(msg) if log_callback else None
    log_func(f"开始Base64编码：{input_path}")
    with open(input_path, "rb") as f:
        base64_bytes = base64.b64encode(f.read())
    base64_str = base64_bytes.decode("utf-8")  # bytes → str
    lines = [base64_str[i:i + line_length] for i in range(0, len(base64_str), line_length)]
    multi_line_base64 = "\n".join(lines)
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(multi_line_base64)
    log_func(f"Base64编码完成：{os.path.basename(output_path)}")


def clean_temp_files(file_list: List[str], log_callback=None) -> None:
    log_func = lambda msg: log_callback(msg) if log_callback else None
    log_func(f"开始清理临时文件，共 {len(file_list)} 个")
    for f in file_list:
        if os.path.exists(f):
            os.remove(f)
            log_func(f"已删除临时文件：{os.path.basename(f)}")


def ssl_encrypt(client_key_path: str, pubkey_path: str, output_dir: str, log_callback=None) -> None:
    log_func = lambda msg: log_callback(msg) if log_callback else None
    log_func(f"=== 开始加密流程 ===")
    log_func(f"待加密文件：{client_key_path}")
    log_func(f"使用公钥：{pubkey_path}")
    log_func(f"输出目录：{output_dir}")

    os.makedirs(output_dir, exist_ok=True)

    try:
        chunk_files = split_file(client_key_path, log_callback=log_callback)
        log_func(f"拆分完成：生成 {len(chunk_files)} 个分片")

        enc_files = []
        for i, cf in enumerate(chunk_files, 1):
            enc_file = encrypt_chunk(cf, pubkey_path, log_callback=log_callback)
            enc_files.append(enc_file)
            log_func(f"加密分片 {i}/{len(chunk_files)}：{os.path.basename(enc_file)}")

        encrypted_bin = os.path.join(output_dir, "encrypted_file.bin")
        merge_enc_files(enc_files, encrypted_bin, log_callback=log_callback)
        log_func(f"合并完成：{os.path.basename(encrypted_bin)}")

        output_filename = f"{os.path.splitext(client_key_path)[0]}_enc.key"
        client_enc_key = os.path.join(output_dir, output_filename)

        base64_encode_file(encrypted_bin, client_enc_key, log_callback=log_callback)
        log_func(f"Base64编码完成：{output_filename}")

        clean_temp_files(chunk_files + enc_files, log_callback=log_callback)
        if os.path.exists(encrypted_bin):
            os.remove(encrypted_bin)
            log_func(f"已删除中间文件：{os.path.basename(encrypted_bin)}")

        log_func(f"=== 加密流程完成 ===")
    except Exception as e:
        error_msg = f"加密失败：{str(e)}"
        log_func(f"ERROR - {error_msg}")
        logging.error(error_msg, exc_info=True)
        raise

def extract_certificate_id(cer_file_path: str, log_callback=None) -> str:
    """
    从证书文件中提取证书ID
    注意：这是一个简化版本，实际实现可能需要根据证书格式调整
    """
    log_func = lambda msg: log_callback(msg) if log_callback else None
    log_func(f"开始提取证书ID：{cer_file_path}")
    try:
        # 读取证书文件
        with open(cer_file_path, 'rb') as cert_file:
            cert_data = cert_file.read()
        #  解析证书（自动处理PEM/DER格式）
        if b"-----BEGIN CERTIFICATE-----" in cert_data:
            cert = x509.load_pem_x509_certificate(cert_data, default_backend())
        else:
            cert = x509.load_der_x509_certificate(cert_data, default_backend())
        # 获取使用者（Subject）信息
        subject = cert.subject
        # 获取使用者名称（Common Name）
        common_name = subject.get_attributes_for_oid(x509.NameOID.COMMON_NAME)
        if common_name:
            return common_name[0].value
        log_func(f"已提取证书ID：{common_name[0].value}")
    except Exception as e:
        print(f"提取证书ID时出错: {e}")
        return None


# ------------------------------
# 日志处理（优化滚动条样式）
# ------------------------------
class QTextEditLogger(logging.Handler):
    def __init__(self, text_edit):
        super().__init__()
        self.text_edit = text_edit
        self.text_edit.setReadOnly(True)
        self.formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
        # 日志框样式：调整圆角为4px，添加滚动条样式
        self.text_edit.setStyleSheet("""
            QTextEdit {
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 4px; /* 圆角缩小 */
                padding: 10px;
                font-family: "Microsoft YaHei", Arial, sans-serif;
                font-size: 13px;
                color: #212529;
            }
            /* 滚动条样式 */
            QScrollBar:vertical {
                border: none;
                background: #f1f1f1;
                width: 8px;
                border-radius: 4px;
            }
            QScrollBar::handle:vertical {
                background: #c1c1c1;
                border-radius: 4px;
                min-height: 20px;
            }
            QScrollBar::handle:vertical:hover {
                background: #a8a8a8;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                border: none;
                background: none;
            }
            QScrollBar:horizontal {
                border: none;
                background: #f1f1f1;
                height: 8px;
                border-radius: 4px;
            }
            QScrollBar::handle:horizontal {
                background: #c1c1c1;
                border-radius: 4px;
                min-width: 20px;
            }
            QScrollBar::handle:horizontal:hover {
                background: #a8a8a8;
            }
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
                border: none;
                background: none;
            }
        """)

    def emit(self, record):
        msg = self.format(record)
        self.text_edit.moveCursor(QTextCursor.MoveOperation.End)
        self.text_edit.insertPlainText(msg + '\n')
        self.text_edit.moveCursor(QTextCursor.MoveOperation.End)

# ------------------------------
# 加密线程（无修改）
# ------------------------------
class EncryptThread(QThread):
    finished_signal = pyqtSignal(bool, str)
    log_signal = pyqtSignal(str)

    def __init__(self, client_key_path, client_cer_path, pubkey_path, output_dir):
        super().__init__()
        self.client_key_path = client_key_path
        self.client_cer_path = client_cer_path
        self.pubkey_path = pubkey_path
        self.output_dir = output_dir

    def run(self):
        try:
            def log_callback(msg):
                self.log_signal.emit(msg)

            ssl_encrypt(
                client_key_path=self.client_key_path,
                pubkey_path=self.pubkey_path,
                output_dir=self.output_dir,
                log_callback=log_callback
            )
            output_filename = f"{os.path.splitext(self.client_key_path)[0]}_enc.key"
            output_path = os.path.join(self.output_dir, output_filename)

            # 获取当前工作目录
            current_dir = os.getcwd()
            ca_dir = str(os.path.join(current_dir, "ca"))  # 创建ca文件夹
            if not os.path.exists(ca_dir):
                os.makedirs(ca_dir)
            files = glob.glob(os.path.join(ca_dir, "*"))
            for file in files:
                if os.path.isfile(file):
                    os.remove(file)
            certid = extract_certificate_id(cer_file_path = self.client_cer_path ,log_callback=log_callback)
            # 新建一个名为"certid.txt"的文件，并将证书ID写如该文件
            certid_file = os.path.join(ca_dir, "certid.txt")
            with open(certid_file, "w") as f:
                f.write(certid)
                f.close()
                log_callback(f"已生成证书ID文件：{certid_file}")

            # 将output_dir目录下生成_enc.key的加密文件移动到ca_dir目录下，并删除源文件
            shutil.move(output_path, ca_dir)
            log_callback(f"已移动加密文件：{output_path}")
            # 将_enc.key的加密文件重命名为client.key
            os.rename(os.path.join(ca_dir, "client_enc.key"), os.path.join(ca_dir, "client.key"))
            log_callback(f"已重命名加密文件：client_enc.key")
            # 将client_cer_path文件复制到ca_dir目录下，并重命名为client.cer
            shutil.copy(self.client_cer_path, os.path.join(ca_dir, "client.cer"))
            log_callback(f"已复制证书文件：{self.client_cer_path}")
            # 通过adb pull拉取tuid.txt文件
            adb_result = subprocess.run([
                'adb', 'pull',
                '/back_up/oemdata/tuid.txt',
                #str(ca_dir / "tuid.txt")
                str(ca_dir)
            ], capture_output=True, text=True)
            if adb_result.returncode == 0:
                log_callback(f"已拉取tuid.txt文件：{ca_dir / 'tuid.txt'}")
            else:
                log_callback(f"拉取tuid.txt文件失败：{adb_result.stderr}")


            self.finished_signal.emit(True, f"加密成功！加密文件已保存至：{ca_dir}")

        except Exception as e:
            self.finished_signal.emit(False, f"加密失败：{str(e)}")
    def stop(self):
        self.terminate()


class Ui_MainWindow(QMainWindow):
    def __init__(self, parent=None):
        super(Ui_MainWindow, self).__init__(parent)
        self.selected_env = "pre"
        # ------------------------------
        # 关键：获取程序实际安装目录（兼容开发/打包环境）
        # ------------------------------
        if getattr(sys, 'frozen', False):
            # 打包后的 exe 环境：sys.frozen 为 True，_MEIPASS 是临时解压目录（单文件模式）
            # 但我们需要 exe 本身所在的目录，而非临时目录
            self.app_path = os.path.dirname(sys.executable)  # 获取 exe 所在目录
        else:
            # 开发环境：获取当前脚本所在目录
            self.app_path = os.path.dirname(os.path.abspath(__file__))

        # 转换为 Path 对象（可选，方便路径拼接）
        self.app_path = Path(self.app_path)

        self.key_files = []
        self.selected_folder = ""
        self.encrypt_thread = None
        self.pubkey_path = ""

        self.setupUi(self)  # 初始化窗体设置
        self.set_style()
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(922, 662)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout()
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.groupBox = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox.setObjectName("groupBox")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.groupBox)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label = QtWidgets.QLabel(self.groupBox)
        self.label.setObjectName("label")
        self.horizontalLayout.addWidget(self.label)
        self.lineEdit = QtWidgets.QLineEdit(self.groupBox)
        self.lineEdit.setObjectName("lineEdit")
        self.horizontalLayout.addWidget(self.lineEdit)
        self.pushButton = QtWidgets.QPushButton(self.groupBox)
        self.pushButton.setObjectName("pushButton")
        self.pushButton.setFixedWidth(100)
        self.pushButton.clicked.connect(self.select_folder)

        self.horizontalLayout.addWidget(self.pushButton)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.verticalLayout_4.addWidget(self.groupBox)
        self.groupBox_2 = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_2.setObjectName("groupBox_2")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.groupBox_2)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.label_2 = QtWidgets.QLabel(self.groupBox_2)
        self.label_2.setObjectName("label_2")
        self.horizontalLayout_2.addWidget(self.label_2)
        self.radioButton = QtWidgets.QRadioButton(self.groupBox_2)
        self.radioButton.setObjectName("radioButton")
        self.radioButton.setChecked(True)
        self.radioButton.toggled.connect(lambda checked: self.set_env("pre") if checked else None)

        self.horizontalLayout_2.addWidget(self.radioButton)
        self.radioButton_2 = QtWidgets.QRadioButton(self.groupBox_2)
        self.radioButton_2.setObjectName("radioButton_2")
        self.radioButton_2.toggled.connect(lambda checked: self.set_env("formal") if checked else None)

        self.horizontalLayout_2.addWidget(self.radioButton_2)
        self.verticalLayout_2.addLayout(self.horizontalLayout_2)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.label_3 = QtWidgets.QLabel(self.groupBox_2)
        self.label_3.setObjectName("label_3")
        self.horizontalLayout_3.addWidget(self.label_3)
        self.lineEdit_2 = QtWidgets.QLineEdit(self.groupBox_2)
        self.lineEdit_2.setObjectName("lineEdit_2")
        self.lineEdit_2.setReadOnly(True)
        self.update_pubkey_path()

        self.horizontalLayout_3.addWidget(self.lineEdit_2)
        self.verticalLayout_2.addLayout(self.horizontalLayout_3)
        self.verticalLayout_4.addWidget(self.groupBox_2)
        self.groupBox_3 = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_3.setObjectName("groupBox_3")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.groupBox_3)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.textEdit = QtWidgets.QTextEdit(self.groupBox_3)
        self.textEdit.setObjectName("textEdit")

        self.verticalLayout_3.addWidget(self.textEdit)
        self.verticalLayout_4.addWidget(self.groupBox_3)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_2.setFixedWidth(220)
        self.pushButton_2.clicked.connect(self.start_encrypt)
        #self.pushButton_2.setEnabled(False)

        self.horizontalLayout_4.addWidget(self.pushButton_2)
        self.pushButton_3 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_3.setObjectName("pushButton_3")
        self.pushButton_3.setFixedWidth(220)
        self.pushButton_3.clicked.connect(self.clear_log)



        self.horizontalLayout_4.addWidget(self.pushButton_3)
        self.verticalLayout_4.addLayout(self.horizontalLayout_4)
        self.verticalLayout_5.addLayout(self.verticalLayout_4)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 922, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.setup_logger()

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def set_style(self):
        """统一设置组件样式（修复圆角和标题）"""
        font = QFont("Microsoft YaHei", 11)
        self.setFont(font)

        # GroupBox 样式：修复标题显示，圆角调整为4px
        group_box_style = """
            QGroupBox {
                font-size: 12px;
                font-weight: bold;
                color: #212529;
                border: 1px solid #dee2e6;
                border-radius: 4px; /* 圆角缩小 */
                background-color: #fafafa;
                margin-top: 12px; /* 增加顶部边距，避免标题被截断 */
            }margin-top: 18px; /* 增大顶部边距，给标题更多空间 */
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 15px;
                top: -4px; /* 调整标题位置，避免被截断 */
                background-color: #fafafa;
                padding: 0 8px;
                height: 16px; /* 明确标题高度，确保显示完整 */
                margin-top: 8px; /* 增大顶部边距，给标题更多空间 */
            }
        """
        for widget in self.findChildren(QGroupBox):
            widget.setStyleSheet(group_box_style)

        # 按钮样式：圆角调整为4px
        button_style = """
            QPushButton {
                background-color: #2196f3;
                color: white;
                border: none;
                border-radius: 4px; /* 圆角缩小 */
                padding: 8px 16px;
                font-size: 11px;
                font-weight: 500;
                cursor: pointer;
            }
            QPushButton:hover {
                background-color: #1976d2;
            }
            QPushButton:disabled {
                background-color: #bbdefb;
                cursor: not-allowed;
            }
            QPushButton#clear_log_btn {
                background-color: #6c757d;
            }
            QPushButton#clear_log_btn:hover {
                background-color: #5a6268;
            }
        """
        self.pushButton.setStyleSheet(button_style)
        self.pushButton_2.setStyleSheet(button_style)
        self.pushButton_3.setStyleSheet(button_style.replace("QPushButton {", "QPushButton#clear_log_btn {"))
        self.pushButton_3.setObjectName("clear_log_btn")

        # 输入框样式：圆角调整为4px
        line_edit_style = """
            QLineEdit {
                border: 1px solid #dee2e6;
                border-radius: 4px; /* 圆角缩小 */
                padding: 8px 12px;
                font-size: 11px;
                background-color: white;
            }
            QLineEdit:read-only {
                background-color: #f8f9fa;
                color: #495057;
            }
        """
        self.lineEdit.setStyleSheet(line_edit_style)
        self.lineEdit_2.setStyleSheet(line_edit_style)

        # 单选框样式（无修改）
        radio_style = """
            QRadioButton {
                font-size: 11px;
                color: #212529;
                margin-right: 20px;
            }
            QRadioButton::indicator {
                width: 16px;
                height: 16px;
                border-radius: 8px;
                border: 2px solid #adb5bd;
            }
            QRadioButton::indicator:checked {
                background-color: #2196f3;
                border-color: #2196f3;
            }
        """
        self.radioButton.setStyleSheet(radio_style)
        self.radioButton_2.setStyleSheet(radio_style)

        # 标签样式（无修改）
        label_style = """
            QLabel {
                font-size: 11px;
                color: #212529;
            }
        """
        for widget in self.findChildren(QLabel):
            widget.setStyleSheet(label_style)

    def update_pubkey_path(self):
        """公钥路径样式调整（圆角同步为4px）"""
        if self.selected_env == "pre":
            # 拼接：exe目录 → public_key → pre_env → publickey.pem
            pubkey_path = self.app_path / "public_key" / "pre_env" / "publickey.pem"
        else:
            pubkey_path = self.app_path / "public_key" / "formal_env" / "publickey.pem"

        self.pubkey_path = str(pubkey_path)
        self.lineEdit_2.setText(self.pubkey_path)
        if not os.path.exists(pubkey_path):
            self.lineEdit_2.setStyleSheet("""
                        QLineEdit {
                            border: 1px solid #dc3545;
                            border-radius: 4px; /* 圆角缩小 */
                            padding: 8px 12px;
                            font-size: 11px;
                            background-color: #fff8f8;
                            color: #dc3545;
                        }
                    """)
            logging.warning(
                f"当前{'' if self.selected_env == 'pre' else '生产'}环境公钥文件不存在：{pubkey_path}\n"
                f"请检查是否已在对应目录放置 publickey.pem 文件"
            )
        else:
            self.lineEdit_2.setStyleSheet("""
                        QLineEdit {
                            border: 1px solid #dee2e6;
                            border-radius: 4px; /* 圆角缩小 */
                            padding: 8px 12px;
                            font-size: 11px;
                            background-color: #f8f9fa;
                            color: #495057;
                        }
                    """)
            logging.info(f"当前公钥文件：{pubkey_path}（校验通过）")

    def set_env(self, env_type: str):
        self.selected_env = env_type
        env_name = "预生产" if env_type == "pre" else "生产"
        logging.info(f"已切换至{env_name}环境")
        self.update_pubkey_path()

    def select_folder(self):
        folder = QFileDialog.getExistingDirectory(self, "选择文件夹路径")
        if folder:
            self.selected_folder = folder
            self.lineEdit.setText(folder)
            self.key_files = [
                os.path.join(root, file)
                for root, dirs, files in os.walk(folder)

                for file in files
                #if file.lower().endswith(".key")
            ]
            print("ffffffffffffffffffffffff")
            print(self.key_files)
        return self.key_files

    def setup_logger(self):
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)
        logger.handlers.clear()

        qt_handler = QTextEditLogger(self.textEdit)
        logger.addHandler(qt_handler)

        console_handler = logging.StreamHandler()
        console_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        logger.addHandler(console_handler)

    def clear_log(self):
        self.textEdit.clear()
        logging.info("日志已清空")

    def update_log(self, msg: str):
        logger = logging.getLogger()
        if msg.startswith("ERROR - "):
            error_msg = msg.replace("ERROR - ", "")
            logger.error(error_msg)
        else:
            logger.info(msg)

    def start_encrypt(self):
        if not self.selected_folder:
            logging.warning("制作罐装文件操作取消：未选择原始证书文件所在文件夹！")
            return

        if not os.path.exists(self.pubkey_path):
            logging.error(f"制作罐装文件操作取消：当前环境公钥文件不存在：{self.pubkey_path}（请检查文件后重试）")
            return

        if not self.key_files:
            logging.warning("制作罐装文件操作取消：未找到原始证书文件！")
            return
         # 找到self.key_files中以.key结尾的文件
        client_key_path = [file for file in self.key_files if file.lower().endswith(".key")]
        print("aaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
        print(os.path.basename(client_key_path[0]))

        client_cer_path = [file for file in self.key_files if file.lower().endswith(".cer")]
        logging.info(
            f"确认加密文件：{os.path.basename(client_key_path[0])}\n"
            f"当前环境：{'预生产' if self.selected_env == 'pre' else '生产'}\n"
            f"开始加密流程..."
        )
        output_dir = os.path.dirname(client_key_path[0]) # 获取原始证书文件所在目录


        self.encrypt_thread = EncryptThread(client_key_path[0], client_cer_path[0], self.pubkey_path, output_dir)




        self.encrypt_thread.finished_signal.connect(self.encrypt_finished)
        self.encrypt_thread.log_signal.connect(self.update_log)
        self.encrypt_thread.start()


        self.pushButton_2.setEnabled(False)
        self.pushButton_2.setText("加密中...")
        self.pushButton.setEnabled(False)
        self.radioButton.setEnabled(False)
        self.radioButton_2.setEnabled(False)




    def update_log(self, msg: str):
        logger = logging.getLogger()
        if msg.startswith("ERROR - "):
            error_msg = msg.replace("ERROR - ", "")
            logger.error(error_msg)
        else:
            logger.info(msg)

    def encrypt_finished(self, success: bool, msg: str):
        self.pushButton_2.setEnabled(True)
        self.pushButton_2.setText("开始加密")
        self.pushButton.setEnabled(True)
        self.radioButton.setEnabled(True)
        self.radioButton_2.setEnabled(True)

        logger = logging.getLogger()
        if success:
            logger.info(f"=== {msg} ===")
        else:
            logger.error(f"=== {msg} ===")



    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.groupBox.setTitle(_translate("MainWindow", "原始证书导入"))
        self.label.setText(_translate("MainWindow", "原始证书位置:"))
        self.pushButton.setText(_translate("MainWindow", "选择文件夹路径"))
        self.groupBox_2.setTitle(_translate("MainWindow", "环境配置"))
        self.label_2.setText(_translate("MainWindow", "运行环境:"))
        self.radioButton.setText(_translate("MainWindow", "预生产环境"))
        self.radioButton_2.setText(_translate("MainWindow", "生产环境"))
        self.label_3.setText(_translate("MainWindow", "公钥选择:"))
        self.groupBox_3.setTitle(_translate("MainWindow", "罐装文件夹制作日志"))
        self.pushButton_2.setText(_translate("MainWindow", "开始制作罐装文件"))
        self.pushButton_3.setText(_translate("MainWindow", "清空日志"))


if __name__ == '__main__':
    app = QtWidgets.QApplication(sys.argv)
    app.setStyle("Fusion")
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor(248, 249, 250))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(33, 37, 41))
    app.setPalette(palette)

    MainWindow = QtWidgets.QMainWindow()  # 创建窗体对象
    ui = Ui_MainWindow()  # 创建PyQt5设计的窗体对象
    ui.setupUi(MainWindow)  # 调用PyQt5窗体的方法对窗体对象进行初始化设置
    MainWindow.show()  # 显示窗体
    sys.exit(app.exec_())  # 程序关闭时退出进程